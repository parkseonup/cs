# 7.1. 프로세스와 스레드 매우중요

- 프로세스의 리소스가 관리될 때 RAM에 직접 접근하는 게 아니라, 주기억장치와 보조기억장치를 합친 가상 메모리(Virtual Memory) 형태로 관리된다.
- 가상메모리는 프로세스 기준으로 전달된다.
  - 스레드는 프로세스에 속해있으므로, 프로세스에 할당된 가상 메모리 공간에 제한없이 자유롭게 접근할 수 있다. === 즉, CPU를 주로 사용하는 것은 스레드다.
  - 다른 프로세스의 가상 메모리에는 접근하지 못하도록 가상 메모리 수준에서 통제하기 때문에 다른 프로세스의 가상 메모리에는 접근할 수 없음.
- OS는 프로세스를 관리할 때 관리에 필요한 정보들을 PCB(Process Control Block)에 잔뜩 담고, 그 정보들로 프로세스를 관리함.
- 스레드를 관리하는 정보는 TCB(Thread Control Block)에 저장
- 프로세스는 제한된 CPU의 자원(Core)을 분할해서 사용함: 시분할사용 -> 엄청 빠른 속도로 시분할이 이뤄지기 때문에 마치 동시에 진행되는 것처럼 보임

### PCB 구조

- PID(Process ID)
- 메모리 정보
  - 가상 메모리에서 명령이 저장된 주소를 저장함

### 가상 메모리 구조

- Stack: 자동변수(지역변수)가 쓰는 것
- Heap: malloc을 할당해서 쓰느 것
- Section: 소스 코드가 기계어로 번역된게 저장되는 영역
- Static(정적 영역)
  - R(읽기 전용, Read): 상수
  - RW(읽기+쓰기, Read+Write): 전역 변수, 또는 정적 변수

## 프로그램과 프로세스의 차이

- 프로그램은 HDD에 설치를 함.
- HDD에 설치된 프로그램을 인스턴스화(실행) 한 것. 즉 실행되고 있는 프로그램
  - 인스턴스화: RAM 메모리에 올리면 PCB 생성, 가상 메모리 할당, 어디서부터 어디까지 실행할건지 분석, 하나씩 정보를 떼와서 연산

## 프로세스의 라이프사이클

1. 생성상태
2. 준비상태
3. 실행상태 or 대기상태

   - 대기상태: 어떤 디바이스에 입출력 요청이 간 뒤 응답을 받기까지 Lock이 걸린 것. 요청이 완료될 때까지를 기다리는 것. === Blocking I/O
   - 요청이 완료되기를 안기다리는 비동기 요청을 하고, 다른 걸 진행하고 있으면 NonBlocking I/O
   - 요청을 해놓고 실행 상태가 유지되면 NonBlocking, 실행 상태가 대기 상태로 빠지면 Blocking

4. 완료상태

- 상태는 전이된다. (변화한다.)
- 상태는 Queue로 관리됨
- CPU의 core가 8개라면, 준비 상태를 저장하는 Queue에서 8개를 dipatch함 -> 자원할당 및 실행이 이뤄짐
