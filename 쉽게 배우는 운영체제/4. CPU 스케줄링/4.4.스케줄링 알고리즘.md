# 4.4. 스케줄링 알고리즘

- 스케줄링 알고리즘은 크게 비선점형 알고리즘(non-preemptive algorism)과 선점형 알고리즘(preemptive algorism)으로 나뉜다.
- 비선점형 알고리즘은 프로세스의 작업이 끝날 때까지 CPU를 독점하는 것으로 효율이 떨어져 지금은 거의 사용되지 않는다.
- 선점형 알고리즘은 시분할 시스템을 고려하여 만들어진 알고리즘이다.

## 스케줄링 알고리즘의 선택 기준

### 평가 기준 종류

- CPU 사용률: 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법
- 처리량: 단위 시간당 작업을 마친 프로세스의 수. 수치가 클수록 좋은 알고리즘
- 대기 시간: 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간. 시간이 짧을수록 좋다.
- 응답 시간: 프로세스 시작 후 첫 번째 출력(반응)이 나올 때까지 걸리는 시간. 시간이 짧을수록 좋다.
- 실행 시간: 프로세스 작업이 시작된 후 종료되기까지 걸리는 시간
- 반환 시간: 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간. 대기 시간과 실행 시간을 더한 값이다.

### 평가시

- CPU 알고리즘의 효율성을 평가할 때 CPU 사용률과 처리량은 계산하기가 어려워 주로 대기 시간, 응답 시간, 반환 시간을 계산한다.
- 스케줄링 알고리즘의 성능을 비교할 때는 주로 평균 대기 시간을 본다. 평균 대기 시간 = 모든 프로세스 대기 시간의 합 / 프로세스 수
- 평균 대기 시간은 작업 패턴에 따라 시간이 역전될 수 있다. 따라서 평균 대기 시간은 알고리즘의 절대적인 성능을 보여주는 지표가 아닌, 알고리즘이 어떻게 작동하는지 파악하는 도구 정도로만 생각해야 한다.

## 종류

- 비선점형 알고리즘: FCFS 스케줄링, SJF 스케줄링, HRN 스케줄링
- 선점형 알고리즘: 라운드 로빈 스케줄링, SRT 스케줄링, 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링
- 둘 다 가능: 우선순위 스케줄링

### FCFS(First Come First Served) 스케줄링

- 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식(선입선출)
- 큐가 하나이기 때문에 모든 프로세스의 우선순위가 동일하다.
- 초기의 일괄 작업 시스템에서 사용되던 스케줄링이다.
- 단순하고 공평하지만, 다른 프로세스들의 대기 시간이 길어지는 콘보이 효과(convoy effect) 또는 호위 효과를 보인다.
  - 콘보이 효과(convoy effect), 호위 효과: 컨베이어 벨트에 작업물이 한 줄로 늘어서 있을 때 앞의 작업이 오래 걸려서 뒤의 작업이 지연되는 현상
- 입출력 요청시 CPU가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어진다.

### SJF(Shortest Job First) 스케줄링

- 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식. === 최단 작업 우선 스케줄링
- FCFS 스케줄링의 콘보이 효과를 완화한 스케줄링
- 입출력으로 인해 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.
  - 프로세스가 자신의 작업 시간을 운영체제에 알려주는 것으로 해결할 수 있으나, 프로세스는 자신의 작업 시간을 정확히 알기 어려울 뿐만 아니라 일부 악의적인 프로세스가 작업 시간을 속일 수 있기 때문에 해결방법으로 보기 어렵다.
- 작업 시간이 길다는 이유만으로 작업 순서가 계속 연기되는 아사(starvation) 또는 무한 봉쇄(infinite blocking) 현상이 발생되므로, 공평성에 위배된다.
  - 프로세스가 양보할 수 있는 상한선을 정하는 에이징(aging, 나이 먹기) 방식으로 해결할 수 있으나, 어떤 기준으로 에이징 값을 정할 것인지가 문제이기 때문에 한계가 있다.
- 결론적으로 프로세스의 종료 시간을 파악하기 어렵고 아사 현상이 일어날 수 있기 때문에 잘 사용하지 않는다.

### HRN(Highest Response Ratio Next) 스케줄링

- SJF 스케줄링의 아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘. === 최고 응답률 우선 스케줄링
- 서비스를 받기 위해 기다린 시간과 CPU 사용시간을 고려하여 스케줄링하는 방식.
- 우선순위 = (대기 시간 + CPU 사용 시간) / CPU 사용 시간
- 우선순위를 정할 때 대기 시간을 고려하기 때문에 아사 현상을 완화함. 즉, 스케줄링 방식에 에이징을 구현함.
- 여전히 공평성이 위배되므로 잘 사용하지 않는다.

### 라운드 로빈(RR, Round Robin) 스케줄링

- 한 프로세스가 타임 슬라이스 ㄷ동안 작업을 하다가 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식. 순환 순서 방식
- FCFS 스케줄링과 유사하나 타임 슬라이스가 있다는 차이가 있음.
- 우선순위가 적용되지 않은 가장 단순한 선점형 스케줄링 방식
- 문맥 교환이 이뤄지는 시간으로 인해 FCFS 스케줄링보다 평균 대기 시간이 적다고 단정할 수 없다.

### SRT(Shortest Remaining Time) 스케줄링

- SJF 스케줄링과 로빈 스케줄링을 혼합한 방식. === 최소 잔류 시간 우선 스케줄링
- 기본적으로 라운드 로빈 스케줄링을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남은 작업 시간이 가장 적은 프로세스를 선택함
- 좋은 알고리즘은 아니기 때문에 잘 사용하지 않는다.
  - 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이 더 적은 프로세스와 문맥 교환을 해야 하는 추가 작업이 필요하다.
  - SJF 스케줄링과 마찬가지로 프로세스 종료 시간을 예측하기 어렵고 아사 현상이 일어난다.

### 우선순위 스케줄링

- 프로세스의 중요도에 따른 우선순위를 반영한 알고리즘
- 어떤 기준으로 우선순위를 정하느냐에 따라 다양하게 구현할 수 있음
- 비선점형 방식과 선점형 방식 모두에 적용할 수 있다.
  - SJF 스케줄링(비선점형 방식): 작업 시간이 짧은 프로세스에 높은 우선순위를 부여한다.
  - HRN 스케줄링(비선점형 방식): 작업 시간이 짧거나 대기 시간이 긴 프로세스에 높은 우선순위를 부여한다.
  - SRT 스케줄링(선점형 방식): 남은 시간ㅇ이 짤ㄹㅂ은 프로세스에 높은 우선순위를 부옇한다.
- 고정 우선순위 알고리즘과 변동 우선순위 알고리즘으로 나뉜다.
  - 고정 우선순위 알고리즘: 한 번 부여받은 우선순위는 종료될 때까지 변동되지 않는다.
  - 변동 우선순위 알고리즘: 일정 시간마다 우선순위를 새로 계산하고 반영한다.
- 준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로 공평성을 위배하고 아사 현상을 일으킨다는 문제가 있다.
- 프로세스의 우선순위를 매번 바꿔야 하기 때문에 오버헤드가 발생하여 시스템 효율이 떨어진다.
- 시스템의 효율성보다 프로세스의 중요도를 보고 채택하여 사용된다.

### 다단계 큐 스케줄링(MLQ, Multi-Level Queue)

- 우선순위에 따라 큐를 여러 개 사용하는 방식
- 프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위의 큐에 삽입된다.
- 라운드 로빈 방식으로 큐가 운영되기 때문에 프로세스가 큐에 삽입되는 것만으로 우선순위가 결정된다.
- 고정형 우선순위를 사용하며, 우선순위가 높은 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작된다.

### 다단계 피드백 큐 스케줄링(MLFQ, Multi-Level Feedback Queue)

- 우선순위가 낮은 프로세스의 작업이 연기되는 다단계 큐 스케줄링을 보완한 방식
- 프로세스가 CPU를 할당받아 실행될 때마다 프로세스의 우선순위를 낮춤으로써, 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화한다.
  - 실행되고 있던 프로세스의 타임 슬라이스가 끝나면 원래있던 우선순위의 큐로 돌아가지 않고, 프로세스의 우선순위를 낮춘 뒤 해당 우선순위 큐의 끝으로 들어간다.
- 커널 프로세스는 일반 프로세스의 큐에 삽입되지 않는다.
- 우선순위에 따라 타임 슬라이스의 크기가 다르다. 우선순위가 낮을수록 타임 슬라이스를 크게 배정하여 어렵게 얻은 CPU를 좀 더 오랫동안 사용할 수 있도록 한다.
  - 유닉스에서 타임 슬라이스를 고정하지 않고 10~200 밀맃초 사이에서 조정할 수 있도록 한 이유
- 오늘날 운영체제가 CPU 스케줄링을 할 때 일반적으로 사용하는 방식으로, 변동 우선순위 알고리즘의 전형적인 예이다.
